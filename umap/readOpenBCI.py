import numpy as np
import pandas as pd
from utils import processSignal

def loadData(datafile,isOpenBci=False):
    data = pd.read_csv(datafile)
    channels = ['AF3', 'F7', 'F3', 'FC5', 'T7', 'P7', 'O1', 'O2', 'P8', 'T8', 'FC6', 'F4', 'F8', 'AF4']
    data.columns = data.columns.str.replace("'",'') # fixing namings in emotiv data

    if isOpenBci:
        channels = ['Fp1','Fp2','C3','C4','T5','T6','O1','O2','F7','F8','F3','F4','T3','T4','P3','P4']
        #channels=['Fp1','Fp2','F7','F3','F4','F8']
        data[channels] = data[channels] * (4500000)/24/(2**23-1) # scale to uVolts
    return data,channels

def parseEvents(df):
    events = []
    index = 0
    while index < len(df):
        if index < len(df) and 'start' in df.iloc[index]['event_id'].lower() and 'end' in df.iloc[index+1]['event_id'].lower():
            events.append({})
            events[int(index/2)]['start'] = df.iloc[index]['timestamp']
            events[int(index/2)]['eventname'] = df.iloc[index]['event_id']
            events[int(index/2)]['end'] = df.iloc[index+1]['timestamp']
            index += 2
        else:
            index += 1
    return events

def parseEventData(data, event, startOfExperiment, endOfExperiment):
    startRatio = (event['start'] - startOfExperiment)/(endOfExperiment - startOfExperiment)
    endRatio = (event['end']- startOfExperiment)/(endOfExperiment - startOfExperiment)
    start = int(startRatio * data.shape[1])
    end = int(endRatio * data.shape[1])

    print(event['start'],event['end'])
    print(start,end)
    return data[:,start:end]



def processData(files=[],labelFiles=[],participants=[],sampleRate = 125,seconds=5,numChannels=16,stft=True,isOpenBci=True,fmin=13,fmax=30,labelsMap={'C1':1}):
    """
    function: processData
    Description: This function processes data generated by gedaps.
    Parameters:
    files: list of files to process
    labelFiles: list of label files to process
    participants: list of participants
    sampleRate: sample rate of the data
    seconds: number of seconds to process
    numChannels: number of channels to process
    stft: boolean to determine if the data should be processed using stft
    isOpenBci: boolean to determine if the data is from openbci
    fmin: minimum frequency to process
    fmax: maximum frequency to process
    labelsMap: dictionary of labels to map to -- example {'C1':1} --- will map all C1 events to 1
    Returns:
    outData: processed data
    outClassLabels: class labels
    outChannels: channels
    outParticipants: participants
    outDimension: dimension of the data
    Extra:
    This function is used to process data from gedaps.
    Stft turns eeg data into a spectrogram and outputs in outData as N*numchannels X spectrogram.
    stft as false outputs the signal data as numchannels X num samples and labels, particpants are shapped as numchannel*num samples.
    """
    seconds = sampleRate * seconds
    outData = None
    outClassLabels = None
    outArousal = []
    outValence = []
    outDominance = []
    outParticipants = []
    outChannels = []
    outDimension = 0
    outEventName = []
    outTime = []
    participant = 0
    #seconds = 125 * 5 # 5 seconds

    for index in range(len(files)):
        if len(participants) > 0:
            participant = participants[index]
        else:
            participant = index
        file = files[index]
        eventsfile = labelFiles[index]
        event = []
        parsedEvents = []
        if eventsfile != None:
            events = pd.read_csv(eventsfile)
            parsedEvents = parseEvents(events)
        eventsOfInterest = []

        if len(labelsMap) != 0:
            for event in parsedEvents:
                for label in labelsMap.keys():
                    if label.lower() in event['eventname'].lower():
                        eventsOfInterest.append((event,labelsMap[label]))
                        break
        else:
            for event in parsedEvents:
                eventsOfInterest.append((event,0))
        #print(eventsOfInterest)
        data,channels = loadData(file,isOpenBci=isOpenBci)
        startOfExperiment = data['WrittenTimestamp'].min()
        data = data[channels].to_numpy()
        time = 0
        if not stft:
            data = data.T
            timeSum = 0
            for i in range(0,data.shape[0]):
                outTime.append(timeSum)
                timeSum += 1/sampleRate
            print(data.shape)
            if not outData is None:
                outData = np.append(outData,data,axis=1)
            else:
                outData = data
            print(outData.shape)
        else: 
            outputData,time,fmaxindex,fminindex = processSignal(data,numChannels=numChannels,seconds=seconds,samplerate=sampleRate,fmin=fmin,fmax=fmax)
            if not outData is None:
                outData = np.append(outData,outputData,axis=0)
            else:
                outData = outputData
        
        # based on events of interest, label the data
        labels = []
        if stft:
            count = 0
            for split in range(numChannels):
                for i in time:
                    outTime.append(i)
                    found = False
                    index = 0
                    for eventPairing in eventsOfInterest:
                        index += 1
                        start = eventPairing[0]['start'] 
                        end = eventPairing[0]['end']
                        if i >= start-startOfExperiment and i < end-startOfExperiment:
                            labels.append(eventPairing[1]['arousal'])
                            outArousal.append(eventPairing[1]['arousal'])
                            outValence.append(eventPairing[1]['valence'])
                            outDominance.append(eventPairing[1]['dominance'])
                            outEventName.append(eventPairing[0]['eventname'].lower())
                            found = True
                            break
                    if not found:
                        labels.append(-1)
                        outArousal.append(-1)
                        outValence.append(-1)
                        outDominance.append(-1)
                        outEventName.append('none')
                    outChannels.append(count % 16)
                    outParticipants.append(participant)
                count += 1
            if outClassLabels is not None:
                outClassLabels = np.append(outClassLabels,labels)
            else:
                outClassLabels = labels
            outDimension= fmaxindex-fminindex+1
        else:
            labels = np.array([-1] * data.shape[1])
            outArousal = np.array([-1] * data.shape[1])
            outValence = np.array([-1] * data.shape[1])
            outDominance = np.array([-1] * data.shape[1])
            outEventName = np.array(['none'] * data.shape[1])
            for eventPairing in eventsOfInterest:
                start = eventPairing[0]['start'] -startOfExperiment
                end = eventPairing[0]['end'] - startOfExperiment
                start = int(start*125)
                end = int(end *125)
                labels[start:end] = eventPairing[1]['arousal']
                outArousal[start:end] = eventPairing[1]['arousal']
                outValence[start:end] = eventPairing[1]['valence']
                outDominance[start:end] = eventPairing[1]['dominance']
                outEventName[start:end] = eventPairing[0]['eventname'].lower()
            for split in range(16):
                outChannels = np.append(outChannels,[split]*data.shape[1])
                outParticipants = np.append(outParticipants,[participant]*data.shape[1])
                if outClassLabels is not None:
                    outClassLabels = np.append(outClassLabels,labels)
                else:
                    outClassLabels = labels
            outArousal = np.array(outArousal*16)
            outValence = np.array(outValence*16)
            outDominance = np.array(outDominance*16)
            outEventName = np.array(outEventName*16)
            outTime = np.array(outTime*16)
    return outData,np.array(outClassLabels),np.array(outArousal),np.array(outValence),np.array(outDominance), np.array(outEventName), outTime, outChannels, outParticipants,outDimension